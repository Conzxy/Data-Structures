# 堆排序
## 基本概念
**堆**，分为大（顶）堆和小（顶）堆，是顺序存储的完全二叉树，并且满足一下特性之一：<br>
(1)    任意非终端结点关键字不小于左右子结点（大堆）

        ki >= k2i+1并且ki>=k2i+2 其中，0 <= i <= (n-1)/2，n是数组元素个数

(2)    任意非终端结点关键字不大于左右子结点（小堆）

        ki <= k2i+1并且ki<=k2i+2 其中，0 <= i <= (n-1)/2，n是数组元素个数
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814235300022-957054963.png)<br>
**调整**<br>
从当前结点（要求是非终端结点）开始，<br>
对于大堆，要求当前结点关键字不小于子结点，如不符合，则将最大的子结点与当前结点交换。循环迭代交换后的子树，确保所有子树都符合大堆特性。
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814235330885-1633949544.png)<br>
小堆类似
## 基本思想
堆排序就是利用**构建堆和输出堆顶元素**的过程，不断对堆进行调整以保证当前结点及其孩子结点满足堆特性，从而达到对初始数组元素进行排序的目的。
核心步骤：

1)构建堆（大堆/小堆）

从最后一个非终端结点开始，向前进行调整，保证当前结点及其子树符合堆特性；

2) 输出有序序列

交换堆顶与末尾叶子结点，堆顶输出到数组的有序序列末尾，而不参与堆的调整。从交换后的堆顶开始调整，以确保当前结点及其子树符合堆特性。
## 实例分析
|初始序列|49|38|65|97|76|13|27|49' |
|---|----|-|-|-|-|-|-|-|
|位置|0|1|2|3|4|5|6|7|

### 1):构建堆
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814235702464-79658121.png)<br>
从最后一个非叶子结点开始，向前进行调整，确保符合特性<br>
最后一个非叶子结点位置：(n-1) / 2 = 3, n=8<br>
总共调整次数：(n-1)/2 +1 =4<br>

第1次调整：选择最后一个非叶子结点元素为97（位置3）为当前父结点，与其子结点进行比较，选择最小的结点作为当前父结点。<br>

|第一次调整后序列|49|38|65|49'|76|13|27|97 |
|---|----|-|-|-|-|-|-|-|
|位置|0|1|2|3|4|5|6|7|

![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814233552311-482820257.png)<br>
第二次调整：选择上一次结点的前一个结点为当前结点进行调整

|第二次调整后序列|49|38|13|49'|76|65|27|97 |
|---|----|-|-|-|-|-|-|-|
|位置|0|1|2|3|4|5|6|7|

![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814233703319-1103120657.png)<br>

第三次调整：

|第三次调整后序列|49|38|13|49'|76|65|27|97 |
|---|----|-|-|-|-|-|-|-|
|位置|0|1|2|3|4|5|6|7|

![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814233827733-1024331288.png)<br>

第四次调整：

|第四次调整后序列|13|38|27|49'|76|65|49|97 |
|---|----|-|-|-|-|-|-|-|
|位置|0|1|2|3|4|5|6|7|

![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814233914896-2129618665.png)<br>

![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814233921049-1530457740.png)<br>
### 2):输出堆顶元素
将已经构建好的小堆，输出堆顶元素，和末尾元素交换，相当于堆顶移动到数组末尾形成有序序列，未排序元素移动到堆顶。从新的堆顶开始进行调整，直到堆重新符合小堆特性。<br>
交换堆顶和末尾（堆的末尾，不包括已经排好序的部分），并将交换后的堆末尾作为有序序列的一部分，而不再属于堆。<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814233959113-1181552630.png)<br>
一次交换后，发现97新的位置比子结点大，需要继续调整。<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190814234016915-381699363.png)<br>
## 实现代码
```cpp
void HeapAdjust(List &L,int i,int len)
{
      if(i>len/2-1)   //若无子树，直接退出
        return ;
      for(int k=2*i+1;k<len;k++)
      {
        if(k+1<len&&L[k+1]>L[k])
        {
          k++;        //若右孩子比左孩子大，则替换
        }

        if(L[i]<L[k])
        {
          swap(L[i],L[k]);
          i=k;        //以最大子节点为当前结点
        }
        else
          break;      //若满足大堆性质，则直接退出
      }
    }

void HeapSort(List &L)
{
    //从最后一个非叶子结点开始向前调整
    for(int i=L.size/2-1;i<L.size;i--)
    {
      HeapAdjust(L,i,L.size);
    }

    //输出并再调整
    for(int j=L.size-1;j>0;j--)
    //j==0没有必要，因为此时只有一个根结点
    {
      swap(L[0],L[j]);
      HeapAdjust(L,0,j);
    }
}
```
