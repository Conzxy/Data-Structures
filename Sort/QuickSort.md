# 快速排序
## 基本思想
每趟使表的第1个元素放入适当位置（归位），并且左边的元素小于这个元素，右面的元素大于这个元素，将表一分为二，对子表按递归方式继续这种划分，直至划分的子表长为0或1（递归出口）。
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190815212143800-1869313412.png)<br>
快速排序二叉递归树：<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190815212307728-17746403.png)<br>

顺带一提，STL的sort的实现原理就是快速排序。
## 实现代码
```cpp
void QuickSort(List &L,int left,int right)
{
    int l=left,r=right;
    int temp=L[left];
    if(l<r)
    {
      while(l!=r)
      {
        while(l<r&&L[r]>=temp)
        {
          r--;
        }
        L[l]=L[r];

        while(l<r&&L[l]<=temp)
        {
          l++;
        }
        L[r]=L[l];
      }
      L[l]=temp;
      QuickSort(L,left,l-1);
      QuickSort(L,l+1,right);
    }
}
```
## 算法复杂度
最好的情况：<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190815212934570-941546711.png)<br>
按照计算，1+2+···+2^(m-1)=2^m-1=n,求得m=log2(n+1),m为深度，n为元素个数,因此所需栈空间的最大深度为log2(n+1)<br>
每次划分所选择的中间数恰好将当前序列几乎等分，经过log2n趟划分，便可得到长度为1的子表。每一趟要比较n个元素，因此整个算法的时间复杂度为O(nlog2n)。<br>
![](https://img-blog.csdnimg.cn/20200531151619133.gif)<br>
最坏的情况：<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190815213005838-477843633.png)<br>
每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另一子表的长度为原表的长度-1。这样，长度为n的数据表的快速排序需要经过n趟划分，使得整个排序算法的时间复杂度为O(n2)<br>
平均情况：<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190815213040831-1022407683.png)
### 补充：
Q：为什么递归树的深度=空间复杂度？
A：尾递归会自动优化代码，不是创建新的堆栈空间压入，而是直接覆盖前面的状态，这样每一个深度覆盖一次，自然就等于递归树的深度了。
