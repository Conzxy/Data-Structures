# 快速排序
## 基本思想
每趟使表的第1个元素放入适当位置（归位），并且左边的元素小于这个元素，右面的元素大于这个元素，我们称这个元素为pivot，将表一分为二，对子表按递归方式继续这种划分，直至划分的子表长为0或1（递归出口）。<br>
![](https://img-blog.csdnimg.cn/20200604185349173.png)<br>
快速排序二叉递归树：<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190815212307728-17746403.png)<br>
正因为是将最左边的元素提取出来当pivot，所以左边都比它小，右边都比它大，继续划分也是如此，因此这个pivot在序列中的位置就已经决定好了，其他的序列继续如此划分，直至最后分到子表长度只有1或0。由于划分是按照整体有序的方式进行的，所以最后得到的序列必然是有序的。<br>
顺带一提，STL的sort的实现原理就是快速排序。因为相比冒泡等时间换空间的算法以及桶排序等空间换时间的算法来说，快排没有严重失衡，得到优化后更是如此，无愧于20世纪十大算法之一。<br>
## 实现代码
```cpp
void QuickSort(List &L,int left,int right)
{
    int l=left,r=right;         //记录此时的左边界和右边边
    int temp=L[left];           //记录左边界为pivot
    if(l<r)
    {
      while(l!=r)
      {
        while(l<r&&L[r]>=temp)  //如果右边的元素大于等于pivot则正常
        {
          r--;              //向pivot靠近
        }
        L[l]=L[r];          //若小于pivot，则调整

        while(l<r&&L[l]<=temp)
        {
          l++;
        }
        L[r]=L[l];
      }
      L[l]=temp;    //最终r<l失败，令其为pivot。
      QuickSort(L,left,l-1);    //划分[left,...,l-1]并进行排序
      QuickSort(L,l+1,right);   //划分[l+1,...,right]并进行排序
    }
}
```
## 算法复杂度
最好的情况：<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190815212934570-941546711.png)<br>
按照计算，1+2+···+2^(m-1)=2^m-1=n,求得m=log2(n+1),m为深度，n为元素个数,因此所需栈空间的最大深度为log2(n+1)<br>
每次划分所选择的中间数恰好将当前序列几乎等分，经过log2n趟划分，便可得到长度为1的子表。每一趟要比较n个元素，因此整个算法的时间复杂度为O(nlog2n)。<br>
![](https://img-blog.csdnimg.cn/20200531151619133.gif)<br>
最坏的情况：<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190815213005838-477843633.png)<br>
每次所选的中间数是当前序列中的最大或最小元素，这使得每次划分所得的子表中一个为空表，另一子表的长度为原表的长度-1。这样，长度为n的数据表的快速排序需要经过n趟划分，使得整个排序算法的时间复杂度为O(n^2)<br>
平均情况：<br>
![](https://img2018.cnblogs.com/blog/1475571/201908/1475571-20190815213040831-1022407683.png)
### 补充：
Q：为什么递归树的深度=空间复杂度？<br>
A：尾递归会自动优化代码，不是创建新的堆栈空间压入，而是直接覆盖前面的状态，这样每一个深度覆盖一次，自然就等于递归树的深度了。
